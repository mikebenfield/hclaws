<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<p>module Math.Integration ( simpson, adaptiveSimpson , adaptiveSimpsonLineIntegral,</p>
<p>circle, circle', lineSegment, lineSegment', box, box', glueCurves ) where</p>
<p>import Data.Matrix as M</p>
<p>import Math.LinearAlgebra</p>
<p>theRightType :: Vector f v =&gt; v -&gt; f theRightType _ = 4</p>
<p>simpson :: (Num f1, Vector f v) =&gt; (f -&gt; v) -&gt; f -&gt; f -&gt; v simpson g a b = factor <em>. (g a +. (4::f)</em>.g m +. g b) where m = (b+a)/2 factor = (b-a)/6</p>
<p>adaptiveSimpson :: Normed f v =&gt; f -&gt; (f -&gt; v) -&gt; f -&gt; f -&gt; v adaptiveSimpson ε f a b = if norm ((sac +. scb) -. sab) / 15 &lt; ε then sac +. scb else adaptiveSimpson ε f a c +. adaptiveSimpson ε f c b where c = (b+a)/2 sab = simpson f a b sac = simpson f a c scb = simpson f c b</p>
<p>--adaptiveSimpsonMat :: Double -&gt; (Double -&gt; Mat) -&gt; Double -&gt; Double -&gt; Mat --adaptiveSimpsonMat ε f a b = fmap</p>
<p>adaptiveSimpsonLineIntegral :: Double-&gt; (Double -&gt; Mat) -&gt; (Double -&gt; Mat) -&gt; (Mat -&gt; Mat) -&gt; Double -&gt; Double -&gt; Double adaptiveSimpsonLineIntegral ε γ γ' ω a b = adaptiveSimpson ε f a b where f t = ((ω $ γ t) * γ' t) M.! (1, 1)</p>
<p>-- some useful curves in R^2</p>
<p>circle :: Mat -&gt; Double -&gt; Double -&gt; Mat circle center radius t = col [radius<em>cos (2</em>pi<em>t), radius</em>sin (2<em>pi</em>t)] + center</p>
<p>circle' :: Double -&gt; Double -&gt; Mat circle' radius t = col [-factor<em>sin (2</em>pi<em>t), factor</em>cos (2<em>pi</em>t)] where factor = 2<em>pi</em>radius</p>
<p>lineSegment :: Mat -&gt; Mat -&gt; Double -&gt; Mat lineSegment p q t = scaleMatrix (1-t) p + scaleMatrix t q</p>
<p>lineSegment' :: Mat -&gt; Mat -&gt; Double -&gt; Mat lineSegment' p q _ = q - p</p>
<p>glueCurves :: [Double -&gt; a] -&gt; Double -&gt; a glueCurves curves t = curve t'' where len = length curves t' = t * fromIntegral len flr = floor t' t'' = t' - (fromIntegral flr) :: Double curve | flr &gt;= fromIntegral len = last curves | otherwise = curves !! flr</p>
<p>box :: Mat -&gt; Double -&gt; Double -&gt; Double -&gt; Mat box lowerLeft width height = glueCurves [lineSegment c1 c2, lineSegment c2 c3, lineSegment c3 c4, lineSegment c4 c1] where e1 = col [width, 0] e2 = col [0, height] c1 = lowerLeft c2 = lowerLeft + e1 c3 = c2 - e2 c4 = lowerLeft + e1</p>
<p>box' :: Double -&gt; Double -&gt; Double -&gt; Mat box' width height = glueCurves [_ -&gt; e1, _ -&gt; e2, _ -&gt; negate e1, _ -&gt; negate e2] where e1 = col [width, 0] :: Mat e2 = col [0, height]</p>
<p>---- γ is the curve we are integrating over ---- ω is a 1-form: interpret its components as the coefficients of dx^i --trapezoidLineIntegral :: (Double -&gt; Vector Double) -&gt; (Vector Double -&gt; Vector Double) -- -&gt; Double -&gt; Double -&gt; Double --trapezoidLineIntegral γ ω a b = -- sum $ map ith [0..len-1] -- where -- m = (b+a)/2 -- γa = γ a -- γb = γ b -- ωa = ω $ γa -- ωb = ω $ γb -- ωm = ω $ γm -- len = length ωa -- --factor i = (γb ! i - γa ! i) / 6 -- --ith i = factor i * (ωa ! i + 4 * ωm ! i + ωb ! i) -- ith i = (γb ! i - γa ! i) * (ωa ! i + ωb ! i) / 2 -- --adaptiveTrapezoidLineIntegral :: Double -&gt; -- (Double -&gt; Vector Double) -&gt; -- (Vector Double -&gt; Vector Double) -&gt; -- Double -&gt; Double -&gt; Double --adaptiveTrapezoidLineIntegral ε γ ω a b = -- if abs ((tac + tcb) - tab) / 15 &lt; ε then -- tac + tcb -- else -- adaptiveTrapezoidLineIntegral ε γ ω a c + -- adaptiveTrapezoidLineIntegral ε γ ω c b --</p>
</body>
</html>
